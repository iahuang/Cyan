make build
g++ -std=c++17 ./src/main.cpp src/memory.cpp src/cyio.cpp src/types/base.cpp -ferror-limit=9999
In file included from ./src/main.cpp:1:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1770:16: error: 'pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef _Tp*              pointer;
               ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1515:22: note: in instantiation of template class 'std::__1::allocator<CyMemory &>' requested here
    typedef typename allocator_type::value_type value_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
./src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from ./src/main.cpp:1:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1771:22: error: 'const_pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef const _Tp*        const_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1785:45: error: multiple overloads of 'address' instantiate to the same signature 'std::__1::allocator<CyMemory &>::const_pointer (std::__1::allocator<CyMemory &>::const_reference) const noexcept' (aka 'int (CyMemory &) const noexcept')
    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
                                            ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1783:39: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT
                                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:950:22: error: implicit instantiation of undefined template 'std::__1::__pointer_traits_element_type<int, false>'
    typedef typename __pointer_traits_element_type<pointer>::type    element_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:22: note: in instantiation of template class 'std::__1::pointer_traits<int>' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
./src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:740:8: note: template is declared here
struct __pointer_traits_element_type;
       ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:53: error: 'rebind' following the 'template' keyword does not refer to a template
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                                                    ^~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
./src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from ./src/main.cpp:1:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:850:22: error: type 'int' cannot be used prior to '::' because it has no members
    typedef typename _Tp::template rebind<_Up> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:954:26: note: in instantiation of template class 'std::__1::__pointer_traits_rebind<int, const void, false>' requested here
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
                         ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1095:53: note: in instantiation of template type alias 'rebind' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
                                                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1520:22: note: in instantiation of template class 'std::__1::__const_void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
./src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from ./src/main.cpp:5:
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:457:30: error: '__alloc_traits' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::__alloc_traits          __alloc_traits;
                             ^
./src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:322:54: note: declared protected here
    typedef allocator_traits<allocator_type>         __alloc_traits;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:458:30: error: 'reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::reference               reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:323:54: note: declared protected here
    typedef value_type&                              reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:459:30: error: 'const_reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_reference         const_reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:324:54: note: declared protected here
    typedef const value_type&                        const_reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:460:30: error: 'size_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::size_type               size_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:54: note: declared protected here
    typedef typename __alloc_traits::size_type       size_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:461:30: error: 'difference_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::difference_type         difference_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:326:54: note: declared protected here
    typedef typename __alloc_traits::difference_type difference_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:462:30: error: 'pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::pointer                 pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:327:54: note: declared protected here
    typedef typename __alloc_traits::pointer         pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:463:30: error: 'const_pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_pointer           const_pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:328:54: note: declared protected here
    typedef typename __alloc_traits::const_pointer   const_pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:671:15: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    value_type*       data() _NOEXCEPT
              ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:674:21: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    const value_type* data() const _NOEXCEPT
                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:691:36: error: multiple overloads of 'push_back' instantiate to the same signature 'void (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)'
    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:688:36: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:708:14: error: multiple overloads of 'insert' instantiate to the same signature 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::iterator (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::const_iterator, std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)' (aka '__wrap_iter<int> (__wrap_iter<int>, CyMemory &)')
    iterator insert(const_iterator __position, value_type&& __x);
             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:705:14: note: previous declaration is here
    iterator insert(const_iterator __position, const_reference __x);
             ^
In file included from ./src/main.cpp:4:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2038:29: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
            __pn->__next_ = __h.get()->__ptr();
                            ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1395:21: note: in instantiation of function template specialization 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__emplace_unique_key_args<std::__1::basic_string<char>, const std::__1::piecewise_construct_t &, std::__1::tuple<std::__1::basic_string<char> &&>, std::__1::tuple<> >' requested here
    return __table_.__emplace_unique_key_args(__k,
                    ^
./src/main.cpp:15:22: note: in instantiation of member function 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::operator[]' requested here
        p->properties["test_variable"] = types::CyInt(loc, 12); // int test_variable = 12;
                     ^
In file included from ./src/main.cpp:4:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2043:23: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
                    = __h.get()->__ptr();
                      ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2050:16: error: static_cast from 'std::__1::unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>, std::__1::__hash_node_destructor<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> > > >::pointer' (aka 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *') to 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__next_pointer' (aka 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> *'), which are not related by inheritance, is not allowed
        __nd = static_cast<__next_pointer>(__h.release());
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
20 errors generated.
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1770:16: error: 'pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef _Tp*              pointer;
               ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1515:22: note: in instantiation of template class 'std::__1::allocator<CyMemory &>' requested here
    typedef typename allocator_type::value_type value_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1771:22: error: 'const_pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef const _Tp*        const_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1785:45: error: multiple overloads of 'address' instantiate to the same signature 'std::__1::allocator<CyMemory &>::const_pointer (std::__1::allocator<CyMemory &>::const_reference) const noexcept' (aka 'int (CyMemory &) const noexcept')
    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
                                            ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1783:39: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT
                                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:950:22: error: implicit instantiation of undefined template 'std::__1::__pointer_traits_element_type<int, false>'
    typedef typename __pointer_traits_element_type<pointer>::type    element_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:22: note: in instantiation of template class 'std::__1::pointer_traits<int>' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:740:8: note: template is declared here
struct __pointer_traits_element_type;
       ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:53: error: 'rebind' following the 'template' keyword does not refer to a template
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                                                    ^~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:850:22: error: type 'int' cannot be used prior to '::' because it has no members
    typedef typename _Tp::template rebind<_Up> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:954:26: note: in instantiation of template class 'std::__1::__pointer_traits_rebind<int, const void, false>' requested here
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
                         ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1095:53: note: in instantiation of template type alias 'rebind' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
                                                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1520:22: note: in instantiation of template class 'std::__1::__const_void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:6:
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:457:30: error: '__alloc_traits' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::__alloc_traits          __alloc_traits;
                             ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:322:54: note: declared protected here
    typedef allocator_traits<allocator_type>         __alloc_traits;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:458:30: error: 'reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::reference               reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:323:54: note: declared protected here
    typedef value_type&                              reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:459:30: error: 'const_reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_reference         const_reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:324:54: note: declared protected here
    typedef const value_type&                        const_reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:460:30: error: 'size_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::size_type               size_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:54: note: declared protected here
    typedef typename __alloc_traits::size_type       size_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:461:30: error: 'difference_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::difference_type         difference_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:326:54: note: declared protected here
    typedef typename __alloc_traits::difference_type difference_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:462:30: error: 'pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::pointer                 pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:327:54: note: declared protected here
    typedef typename __alloc_traits::pointer         pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:463:30: error: 'const_pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_pointer           const_pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:328:54: note: declared protected here
    typedef typename __alloc_traits::const_pointer   const_pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:671:15: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    value_type*       data() _NOEXCEPT
              ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:674:21: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    const value_type* data() const _NOEXCEPT
                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:691:36: error: multiple overloads of 'push_back' instantiate to the same signature 'void (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)'
    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:688:36: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:708:14: error: multiple overloads of 'insert' instantiate to the same signature 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::iterator (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::const_iterator, std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)' (aka '__wrap_iter<int> (__wrap_iter<int>, CyMemory &)')
    iterator insert(const_iterator __position, value_type&& __x);
             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:705:14: note: previous declaration is here
    iterator insert(const_iterator __position, const_reference __x);
             ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2038:29: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
            __pn->__next_ = __h.get()->__ptr();
                            ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1386:21: note: in instantiation of function template specialization 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__emplace_unique_key_args<std::__1::basic_string<char>, const std::__1::piecewise_construct_t &, std::__1::tuple<const std::__1::basic_string<char> &>, std::__1::tuple<> >' requested here
    return __table_.__emplace_unique_key_args(__k,
                    ^
src/memory.cpp:8:22: note: in instantiation of member function 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::operator[]' requested here
    return properties[name];
                     ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2043:23: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
                    = __h.get()->__ptr();
                      ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2050:16: error: static_cast from 'std::__1::unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>, std::__1::__hash_node_destructor<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> > > >::pointer' (aka 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *') to 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__next_pointer' (aka 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> *'), which are not related by inheritance, is not allowed
        __nd = static_cast<__next_pointer>(__h.release());
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2038:29: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
            __pn->__next_ = __h.get()->__ptr();
                            ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:1157:16: note: in instantiation of function template specialization 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__emplace_unique_key_args<std::__1::basic_string<char>, const std::__1::pair<const std::__1::basic_string<char>, obj_ptr> &>' requested here
        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
               ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1377:18: note: in instantiation of member function 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__insert_unique' requested here
        __table_.__insert_unique(*__first);
                 ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1259:5: note: in instantiation of function template specialization 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::insert<std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> > >' requested here
    insert(__u.begin(), __u.end());
    ^
src/memory.hpp:30:7: note: in instantiation of member function 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::unordered_map' requested here
class Object {
      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1715:18: note: in instantiation of function template specialization 'std::__1::allocator<Object>::construct<Object, const Object &>' requested here
            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}
                 ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1561:14: note: in instantiation of function template specialization 'std::__1::allocator_traits<std::__1::allocator<Object> >::__construct<Object, const Object &>' requested here
            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),
             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:1593:25: note: in instantiation of function template specialization 'std::__1::allocator_traits<std::__1::allocator<Object> >::construct<Object, const Object &>' requested here
        __alloc_traits::construct(this->__alloc(),
                        ^
src/memory.cpp:16:10: note: in instantiation of member function 'std::__1::vector<Object, std::__1::allocator<Object> >::push_back' requested here
    pool.push_back(o);
         ^
In file included from src/memory.cpp:1:
In file included from src/memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2043:23: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
                    = __h.get()->__ptr();
                      ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2050:16: error: static_cast from 'std::__1::unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>, std::__1::__hash_node_destructor<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> > > >::pointer' (aka 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *') to 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__next_pointer' (aka 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> *'), which are not related by inheritance, is not allowed
        __nd = static_cast<__next_pointer>(__h.release());
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
23 errors generated.
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1770:16: error: 'pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef _Tp*              pointer;
               ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1515:22: note: in instantiation of template class 'std::__1::allocator<CyMemory &>' requested here
    typedef typename allocator_type::value_type value_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1771:22: error: 'const_pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef const _Tp*        const_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1785:45: error: multiple overloads of 'address' instantiate to the same signature 'std::__1::allocator<CyMemory &>::const_pointer (std::__1::allocator<CyMemory &>::const_reference) const noexcept' (aka 'int (CyMemory &) const noexcept')
    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
                                            ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1783:39: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT
                                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:950:22: error: implicit instantiation of undefined template 'std::__1::__pointer_traits_element_type<int, false>'
    typedef typename __pointer_traits_element_type<pointer>::type    element_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:22: note: in instantiation of template class 'std::__1::pointer_traits<int>' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:740:8: note: template is declared here
struct __pointer_traits_element_type;
       ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:53: error: 'rebind' following the 'template' keyword does not refer to a template
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                                                    ^~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:850:22: error: type 'int' cannot be used prior to '::' because it has no members
    typedef typename _Tp::template rebind<_Up> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:954:26: note: in instantiation of template class 'std::__1::__pointer_traits_rebind<int, const void, false>' requested here
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
                         ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1095:53: note: in instantiation of template type alias 'rebind' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
                                                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1520:22: note: in instantiation of template class 'std::__1::__const_void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:3:
In file included from src/memory.hpp:6:
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:457:30: error: '__alloc_traits' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::__alloc_traits          __alloc_traits;
                             ^
src/memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:322:54: note: declared protected here
    typedef allocator_traits<allocator_type>         __alloc_traits;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:458:30: error: 'reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::reference               reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:323:54: note: declared protected here
    typedef value_type&                              reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:459:30: error: 'const_reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_reference         const_reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:324:54: note: declared protected here
    typedef const value_type&                        const_reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:460:30: error: 'size_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::size_type               size_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:54: note: declared protected here
    typedef typename __alloc_traits::size_type       size_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:461:30: error: 'difference_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::difference_type         difference_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:326:54: note: declared protected here
    typedef typename __alloc_traits::difference_type difference_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:462:30: error: 'pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::pointer                 pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:327:54: note: declared protected here
    typedef typename __alloc_traits::pointer         pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:463:30: error: 'const_pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_pointer           const_pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:328:54: note: declared protected here
    typedef typename __alloc_traits::const_pointer   const_pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:671:15: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    value_type*       data() _NOEXCEPT
              ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:674:21: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    const value_type* data() const _NOEXCEPT
                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:691:36: error: multiple overloads of 'push_back' instantiate to the same signature 'void (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)'
    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:688:36: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:708:14: error: multiple overloads of 'insert' instantiate to the same signature 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::iterator (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::const_iterator, std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)' (aka '__wrap_iter<int> (__wrap_iter<int>, CyMemory &)')
    iterator insert(const_iterator __position, value_type&& __x);
             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:705:14: note: previous declaration is here
    iterator insert(const_iterator __position, const_reference __x);
             ^
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:3:
In file included from src/types/../memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2038:29: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
            __pn->__next_ = __h.get()->__ptr();
                            ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1395:21: note: in instantiation of function template specialization 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__emplace_unique_key_args<std::__1::basic_string<char>, const std::__1::piecewise_construct_t &, std::__1::tuple<std::__1::basic_string<char> &&>, std::__1::tuple<> >' requested here
    return __table_.__emplace_unique_key_args(__k,
                    ^
src/cyio.cpp:12:18: note: in instantiation of member function 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::operator[]' requested here
    p->properties["print"] = types::CyFunc(loc, cyPrint);
                 ^
In file included from src/cyio.cpp:1:
In file included from src/cyio.hpp:3:
In file included from src/types/../memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2043:23: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
                    = __h.get()->__ptr();
                      ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2050:16: error: static_cast from 'std::__1::unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>, std::__1::__hash_node_destructor<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> > > >::pointer' (aka 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *') to 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__next_pointer' (aka 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> *'), which are not related by inheritance, is not allowed
        __nd = static_cast<__next_pointer>(__h.release());
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
20 errors generated.
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1770:16: error: 'pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef _Tp*              pointer;
               ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1515:22: note: in instantiation of template class 'std::__1::allocator<CyMemory &>' requested here
    typedef typename allocator_type::value_type value_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1771:22: error: 'const_pointer' declared as a pointer to a reference of type 'CyMemory &'
    typedef const _Tp*        const_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1785:45: error: multiple overloads of 'address' instantiate to the same signature 'std::__1::allocator<CyMemory &>::const_pointer (std::__1::allocator<CyMemory &>::const_reference) const noexcept' (aka 'int (CyMemory &) const noexcept')
    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT
                                            ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1783:39: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT
                                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:950:22: error: implicit instantiation of undefined template 'std::__1::__pointer_traits_element_type<int, false>'
    typedef typename __pointer_traits_element_type<pointer>::type    element_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:22: note: in instantiation of template class 'std::__1::pointer_traits<int>' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:740:8: note: template is declared here
struct __pointer_traits_element_type;
       ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1072:53: error: 'rebind' following the 'template' keyword does not refer to a template
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;
                                                    ^~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1519:22: note: in instantiation of template class 'std::__1::__void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:2:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/any:85:
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:850:22: error: type 'int' cannot be used prior to '::' because it has no members
    typedef typename _Tp::template rebind<_Up> type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:954:26: note: in instantiation of template class 'std::__1::__pointer_traits_rebind<int, const void, false>' requested here
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
                         ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1095:53: note: in instantiation of template type alias 'rebind' requested here
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
                                                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/memory:1520:22: note: in instantiation of template class 'std::__1::__const_void_pointer<int, std::__1::allocator<CyMemory &>, false>' requested here
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:22: note: in instantiation of template class 'std::__1::allocator_traits<std::__1::allocator<CyMemory &> >' requested here
    typedef typename __alloc_traits::size_type       size_type;
                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:448:15: note: in instantiation of template class 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    : private __vector_base<_Tp, _Allocator>
              ^
src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:6:
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:457:30: error: '__alloc_traits' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::__alloc_traits          __alloc_traits;
                             ^
src/types/../memory.hpp:25:23: note: in instantiation of template class 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >' requested here
    vector<CyMemory&> references;
                      ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:322:54: note: declared protected here
    typedef allocator_traits<allocator_type>         __alloc_traits;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:458:30: error: 'reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::reference               reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:323:54: note: declared protected here
    typedef value_type&                              reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:459:30: error: 'const_reference' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_reference         const_reference;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:324:54: note: declared protected here
    typedef const value_type&                        const_reference;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:460:30: error: 'size_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::size_type               size_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:325:54: note: declared protected here
    typedef typename __alloc_traits::size_type       size_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:461:30: error: 'difference_type' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::difference_type         difference_type;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:326:54: note: declared protected here
    typedef typename __alloc_traits::difference_type difference_type;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:462:30: error: 'pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::pointer                 pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:327:54: note: declared protected here
    typedef typename __alloc_traits::pointer         pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:463:30: error: 'const_pointer' is a protected member of 'std::__1::__vector_base<CyMemory &, std::__1::allocator<CyMemory &> >'
    typedef typename __base::const_pointer           const_pointer;
                             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:328:54: note: declared protected here
    typedef typename __alloc_traits::const_pointer   const_pointer;
                                                     ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:671:15: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    value_type*       data() _NOEXCEPT
              ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:674:21: error: 'data' declared as a pointer to a reference of type 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type' (aka 'CyMemory &')
    const value_type* data() const _NOEXCEPT
                    ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:691:36: error: multiple overloads of 'push_back' instantiate to the same signature 'void (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)'
    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:688:36: note: previous declaration is here
    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
                                   ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:708:14: error: multiple overloads of 'insert' instantiate to the same signature 'std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::iterator (std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::const_iterator, std::__1::vector<CyMemory &, std::__1::allocator<CyMemory &> >::value_type &)' (aka '__wrap_iter<int> (__wrap_iter<int>, CyMemory &)')
    iterator insert(const_iterator __position, value_type&& __x);
             ^
/Library/Developer/CommandLineTools/usr/include/c++/v1/vector:705:14: note: previous declaration is here
    iterator insert(const_iterator __position, const_reference __x);
             ^
src/types/base.cpp:34:35: error: no viable overloaded '='
        x->properties["toString"] = f;
        ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~
src/types/../memory.hpp:15:7: note: candidate function (the implicit move assignment operator) not viable: no known conversion from 'obj_ptr' to 'obj_ptr &&' for 1st argument
class obj_ptr {
      ^
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2038:29: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
            __pn->__next_ = __h.get()->__ptr();
                            ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:1395:21: note: in instantiation of function template specialization 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__emplace_unique_key_args<std::__1::basic_string<char>, const std::__1::piecewise_construct_t &, std::__1::tuple<std::__1::basic_string<char> &&>, std::__1::tuple<> >' requested here
    return __table_.__emplace_unique_key_args(__k,
                    ^
src/types/base.cpp:18:24: note: in instantiation of member function 'std::__1::unordered_map<std::__1::basic_string<char>, obj_ptr, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, obj_ptr> > >::operator[]' requested here
        msg->properties["toString"] = f;
                       ^
In file included from src/types/base.cpp:1:
In file included from src/types/base.hpp:2:
In file included from src/types/../memory.hpp:5:
In file included from /Library/Developer/CommandLineTools/usr/include/c++/v1/unordered_map:369:
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2043:23: error: cannot initialize object parameter of type 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *>' with an expression of type 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>'
                    = __h.get()->__ptr();
                      ^~~~~~~~~
/Library/Developer/CommandLineTools/usr/include/c++/v1/__hash_table:2050:16: error: static_cast from 'std::__1::unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *>, std::__1::__hash_node_destructor<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> > > >::pointer' (aka 'std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *') to 'std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr> > >::__next_pointer' (aka 'std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, obj_ptr>, void *> *> *'), which are not related by inheritance, is not allowed
        __nd = static_cast<__next_pointer>(__h.release());
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
21 errors generated.
make[1]: *** [build] Error 1
make: *** [run] Error 2
